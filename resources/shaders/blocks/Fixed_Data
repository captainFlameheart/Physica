// IMPORTANT TODO: Switch to std430 layout if shared layout does not match needs!
const float pi = 3.141592653589793;

const uint uint_size_shift = 2u;
const uint uint_size = 1u << uint_size_shift;

const uint uvec4_size_shift = 4u;
const uint uvec4_size = 1u << uvec4_size_shift;

const uint alignment = 128u;	// Must be power of two and at least 4!
const uint align_up_addition = alignment - 1u;
const uint align_up_mask = ~align_up_addition;

const uint point_mass_distance_constraint_is_dead_shift = 0u;
const uint point_mass_distance_constraint_is_dead_mask = 1u << point_mass_distance_constraint_is_dead_shift;

const uint point_mass_distance_constraint_observe_impulse_0_shift = 1u;
const uint point_mass_distance_constraint_observe_impulse_0_mask = 1u << point_mass_distance_constraint_observe_impulse_0_shift;

const uint point_mass_distance_constraint_observe_impulse_1_shift = 2u;
const uint point_mass_distance_constraint_observe_impulse_1_mask = 1u << point_mass_distance_constraint_observe_impulse_1_shift;

const uint point_mass_distance_constraint_observe_impulses_mask = point_mass_distance_constraint_observe_impulse_0_mask | point_mass_distance_constraint_observe_impulse_1_mask;

const uint dispatch_command_enabled_shift = 0u;
const uint dispatch_command_enabled_mask = 1u << dispatch_command_enabled_shift;

const uint draw_arrays_command_enabled_shift = 0u;
const uint draw_arrays_command_enabled_mask = 1u << draw_arrays_command_enabled_shift;

struct Dispatch_Command
{
	uint work_group_count_x;
	uint work_group_count_y;
	uint work_group_count_z;
	uint pad;
};

struct Draw_Arrays_Command {
    uint count;
    uint instance_count;
    uint first;
    uint base_instance;
};

uint align_up(uint address)
{
	return (address + align_up_addition) & align_up_mask;
}

uint address_to_uvec4_index(uint address)
{
	return address >> uvec4_size_shift;
}

uint address_to_uint_index(uint address)
{
	return address >> uint_size_shift;
}

layout(shared, binding = fixed_data_binding) FIXED_DATA_RESTRICT_PLACEHOLDER
FIXED_DATA_BUFFER_PLACEHOLDER Fixed_Data
{
	uvec4 camera_position;	// (x, y, z, 0u)
	mat4 camera_offset_to_clip_coordinates;

	uint point_mass_position_velocity_base;
	uint point_mass_inverse_mass_base;
	uint point_mass_constraint_count_base;

	uint point_mass_read_force_turn_flags_base;
	uint point_mass_read_impulses_base;

	uint point_mass_write_force_turn_flags_base;
	uint point_mass_write_impulses_base;

	uint point_mass_capacity;
	
	uint point_mass_distance_constraint_flags_base;
	uint point_mass_distance_constraint_indices_turns_base;
	uint point_mass_distance_constraint_target_distance_base;
	uint point_mass_distance_constraint_applied_forces_base;
	uint point_mass_distance_constraint_impulses_base;
	uint point_mass_distance_constraint_position_impulses_base;

	uint point_mass_distance_constraint_capacity;

	uint point_mass_uniform_force_constraint_indices_turns_base;
	uint point_mass_uniform_force_constraint_target_and_applied_forces_base;
	uint point_mass_uniform_force_constraint_impulses_base;

	uint point_mass_uniform_force_constraint_capacity;

	// TODO: Pad counts to avoid false sharing (unnecessary conflicts during atomic additions)
	uint read_counts[entity_type_count];
	uint write_counts[entity_type_count];

	// TODO: Move commands into buffer that uses std430 to guarantee correct layout for indirect calls
	uint dispatch_command_flags[dispatch_program_count];
	Dispatch_Command dispatch_commands[dispatch_program_count];
	
	uint draw_arrays_command_flags[draw_arrays_program_count];
	Draw_Arrays_Command draw_arrays_commands[draw_arrays_program_count];
} fixed_data;
