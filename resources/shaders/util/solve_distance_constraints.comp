struct Distance_Constraint
{
	uvec2 bodies;
	vec2 local_points[2u];
	vec2 offsets[2u];
	vec2 direction;
	float max_distance;
	float target_velocity;
	float mass;
	float impulse;
};

layout(shared, binding = DISTANCE_CONSTRAINT_BINDING) restrict
buffer Distance_Constraints
{
	readonly uint count;
	Distance_Constraint distance_constraints[MAX_DISTANCE_CONSTRAINT_COUNT];
} distance_constraints;

layout(shared, binding = VELOCITY_SNAPSHOT_BINDING) restrict readonly
buffer Velocities_Snapshot
{
	ivec4 v[MAX_RIGID_BODY_COUNT];
} velocities_snapshot;

layout(shared, binding = VELOCITY_BINDING) restrict
buffer Velocities
{
	ivec4 v[MAX_RIGID_BODY_COUNT];
} velocities;

layout(shared, binding = BODY_MASSES_BINDING) restrict readonly
buffer Body_Masses
{
	vec2 masses[MAX_RIGID_BODY_COUNT];	// mass: (inverse_mass, inverse_inertia)
} body_masses;

layout(local_size_x = LOCAL_SIZE) in;
void main()
{
	if (gl_GlobalInvocationID.x >= distance_constraints.count)
	{
		return;
	}

	uvec2 bodies = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].bodies;
	vec2 offset_0 = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].offsets[0u];
	vec2 offset_1 = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].offsets[1u];
	vec2 direction = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].direction;
	float target_velocity = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].target_velocity;
	float mass = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].mass;
	float impulse = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].impulse;

	ivec4 read_velocity_0 = velocities_snapshot.v[bodies.x];
	ivec4 read_velocity_1 = velocities_snapshot.v[bodies.y];

	// TODO: Fetch masses from buffer
	vec2 mass_0 = body_masses.masses[bodies.x];
	float inverse_mass_0 = mass_0.x;
	float inverse_inertia_0 = mass_0.y;

	vec2 mass_1 = body_masses.masses[bodies.y];
	float inverse_mass_1 = mass_1.x;
	float inverse_inertia_1 = mass_1.y;

	/*float inverse_mass_0 = INVERSE_MASS;
	float inverse_inertia_0 = INVERSE_INERTIA;

	float inverse_mass_1 = INVERSE_MASS;
	float inverse_inertia_1 = INVERSE_INERTIA;*/

	vec3 velocity_0 = vec3(read_velocity_0.xyz);
	vec3 velocity_1 = vec3(read_velocity_1.xyz);
	float velocity = dot(
		(velocity_0.xy - velocity_1.xy) * INVERSE_METER + (offset_0 * velocity_0.z - offset_1 * velocity_1.z) * INVERSE_RADIAN,
		direction
	);
	float old_impulse = impulse;
	impulse = max(0.0, impulse + IMPULSE_SCALE * mass * (target_velocity + velocity));
	float delta_impulse = impulse - old_impulse;
	vec2 delta_impulse_vector = delta_impulse * direction;

	ivec3 delta_velocity_0 = ivec3
	(
		-METER * inverse_mass_0 * delta_impulse_vector, 
		-RADIAN * inverse_inertia_0 * dot(delta_impulse_vector, offset_0)
	);

	ivec3 delta_velocity_1 = ivec3
	(
		METER * inverse_mass_1 * delta_impulse_vector, 
		RADIAN * inverse_inertia_1 * dot(delta_impulse_vector, offset_1)
	);

	distance_constraints.distance_constraints[gl_GlobalInvocationID.x].impulse = impulse;

	atomicAdd(velocities.v[bodies.x].x, delta_velocity_0.x);
	atomicAdd(velocities.v[bodies.x].y, delta_velocity_0.y);
	atomicAdd(velocities.v[bodies.x].z, delta_velocity_0.z);

	atomicAdd(velocities.v[bodies.y].x, delta_velocity_1.x);
	atomicAdd(velocities.v[bodies.y].y, delta_velocity_1.y);
	atomicAdd(velocities.v[bodies.y].z, delta_velocity_1.z);
}
