const float positive_infinity = uintBitsToFloat(0x7F800000);
const float negative_infinity = uintBitsToFloat(0xFF800000);

layout(shared, binding = FLUID_TRIANGLE_CONTACT_COUNT_BINDING) uniform Fluid_Triangle_Contact_Count
{
	uint count;
} fluid_triangle_contact_count;

// TODO: Add friction data?
struct Fluid_Triangle_Contact
{
	uint triangle;
	float mass;
	float impulse;
	uint particle;
	uint body;
	float target_velocity;
	vec2 offset;
	vec2 direction;
	vec2 impulse_range;
};

layout(shared, binding = FLUID_TRIANGLE_CONTACT_BINDING) restrict
buffer Fluid_Triangle_Contacts
{
	Fluid_Triangle_Contact contacts[MAX_FLUID_TRIANGLE_CONTACT_COUNT];
} fluid_triangle_contacts;

layout(shared, binding = POSITION_BINDING) restrict readonly
buffer Positions
{
	ivec4 p[MAX_RIGID_BODY_COUNT];
} positions;

layout(shared, binding = TRIANGLE_BINDING) restrict readonly
buffer Triangles
{
	uvec4 triangles[MAX_TRIANGLE_COUNT];	// Triangle: (vertex_0, vertex_1, vertex_2, body)
} triangles;

layout(shared, binding = VERTEX_BINDING) restrict readonly
buffer Vertices
{
	vec2 vertices[MAX_VERTEX_COUNT];
} vertices;

layout(shared, binding = FLUID_POSITION_BINDING) restrict readonly
buffer Fluid_Position
{
	ivec2 p[MAX_FLUID_PARTICLE_COUNT];
} fluid_position;

layout(shared, binding = FLUID_VELOCITY_BINDING) restrict readonly
buffer Fluid_Velocity
{
	ivec2 v[MAX_FLUID_PARTICLE_COUNT];
} fluid_velocity;

layout(shared, binding = VELOCITY_BINDING) restrict readonly
buffer Velocities
{
	ivec4 v[MAX_RIGID_BODY_COUNT];
} velocities;

layout(shared, binding = BODY_MASSES_BINDING) restrict readonly
buffer Body_Masses
{
	vec2 masses[MAX_RIGID_BODY_COUNT];	// mass: (inverse_mass, inverse_inertia)
} body_masses;

uniform uint persistent_count;

layout(local_size_x = LOCAL_SIZE) in;
void main()
{
	uint index = persistent_count + gl_GlobalInvocationID.x;
	if (index >= fluid_triangle_contact_count.count)
	{
		return;
	}

	uint triangle_index = fluid_triangle_contacts.contacts[index].triangle;
	uint particle_index = fluid_triangle_contacts.contacts[index].particle;

	uvec4 triangle = triangles.triangles[triangle_index];

	vec2 local_vertices[3u] = vec2[3u]
	(
		vertices.vertices[triangle.x], 
		vertices.vertices[triangle.y], 
		vertices.vertices[triangle.z]
	);

	fluid_triangle_contacts.contacts[index].body = triangle.w;

	ivec4 body_position = positions.p[triangle.w];

	ivec2 particle_position = fluid_position.p[particle_index];

	vec2 particle_offset = vec2(particle_position - body_position.xy);
	float angle = body_position.z * RADIAN_INVERSE;
	vec2 right = vec2(cos(angle), sin(angle));
	vec2 up = vec2(-right.y, right.x);
	vec2 local_particle_position = vec2(dot(particle_offset, right), dot(particle_offset, up));

	// TODO: Remove branching

	vec2 normals[3u] = vec2[3u]
	(
		local_vertices[0u] - local_vertices[1u], 
		local_vertices[1u] - local_vertices[2u], 
		local_vertices[2u] - local_vertices[0u]
	);
	normals[0u] = normalize(vec2(normals[0u].y, -normals[0u].x));
	normals[1u] = normalize(vec2(normals[1u].y, -normals[1u].x));
	normals[2u] = normalize(vec2(normals[2u].y, -normals[2u].x));

	// TODO: Remove branching

	uint reference_edge = 0u;
	vec2 vertex_0_to_particle = local_particle_position - local_vertices[0u];
	float min_penetration = dot(normals[0u], vertex_0_to_particle);

	vec2 vertex_1_to_particle = local_particle_position - local_vertices[1u];
	float penetration = dot(normals[1u], vertex_1_to_particle);
	if (penetration < min_penetration)
	{
		reference_edge = 1u;
		min_penetration = penetration;
	}

	vec2 vertex_2_to_particle = local_particle_position - local_vertices[2u];
	penetration = dot(normals[2u], vertex_2_to_particle);
	if (penetration < min_penetration)
	{
		reference_edge = 2u;
		min_penetration = penetration;
	}

	min_penetration *= METER_INVERSE;
	min_penetration += 0.15;
	if (min_penetration < 0.0)
	{
		fluid_triangle_contacts.contacts[index].mass = 0.0;
		return;
	}

	vec2 offset = METER_INVERSE * vec2(-particle_offset.y, particle_offset.x);
	vec2 direction = normals[reference_edge];
	direction = direction.x * right + direction.y * up;

	// TODO: Fetch from buffer
	float particle_inverse_mass = PARTICLE_INVERSE_MASS;
	vec2 body_mass = body_masses.masses[triangle.w];
	float body_inverse_mass = body_mass.x;//BODY_INVERSE_MASS;
	float body_inverse_inertia = body_mass.y;//BODY_INVERSE_INERTIA;

	float old_mass = fluid_triangle_contacts.contacts[index].mass;

	float temp = dot(offset, direction);
	float mass = 1.0 / (
		particle_inverse_mass + 
		body_inverse_mass + body_inverse_inertia * temp * temp
	);
	fluid_triangle_contacts.contacts[index].mass = mass;

	vec2 particle_velocity = vec2(fluid_velocity.v[particle_index]);
	vec3 body_velocity = vec3(velocities.v[triangle.w]);
	float velocity = dot
	(
		direction, 
		(particle_velocity - body_velocity.xy) * METER_INVERSE - offset * (body_velocity.z * RADIAN_INVERSE)
	);
	float target_velocity = 1.0 * min(0.0, velocity); // Is min necessary?
	// IMPORTANT TODO: COMPUTE (SCALED) INITIAL IMPULSE BASED ON VELOCITY FOR FASTER CONVERGENCE
	fluid_triangle_contacts.contacts[index].impulse = 0.0;

	// IMPORTANT TODO: Always change impulse slightly based on velocities for faster convergence
	fluid_triangle_contacts.contacts[index].target_velocity = target_velocity;
	fluid_triangle_contacts.contacts[index].offset = offset;
	fluid_triangle_contacts.contacts[index].direction = direction;
	fluid_triangle_contacts.contacts[index].impulse_range = vec2(0.0, positive_infinity);
}
