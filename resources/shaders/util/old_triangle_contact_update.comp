// IMPORTANT TODO: We need to take a snapshot of the body positions

//#define ALLOWED_PENETRATION 0.2 * METER
//#define POSITION_IMPULSE_SCALE 0.2 * METER_INVERSE

layout(shared, binding = CONTACT_BINDING) restrict readonly
buffer Contacts
{
	uvec2 contacts[MAX_CONTACT_COUNT];
} contacts;

layout(shared, binding = TRIANGLE_BINDING) restrict readonly
buffer Triangles
{
	uvec4 triangles[MAX_TRIANGLE_COUNT];	// Triangle: (vertex_0, vertex_1, vertex_2, body)
} triangles;

/*layout(shared, binding = POSITION_SNAPSHOT_BINDING) restrict readonly
buffer Positions_Snapshot
{
	ivec4 p[MAX_RIGID_BODY_COUNT];
} positions_snapshot;*/

layout(shared, binding = VERTEX_BINDING) restrict readonly
buffer Vertices
{
	vec2 vertices[MAX_VERTEX_COUNT];
} vertices;

struct Contact_Point_Position
{
	vec2 offsets[2];
};

struct Contact_Point_Tangent
{
	float mass;
	float impulse;
};

struct Contact_Point_Normal
{
	float target_velocity;
	float mass;
	float impulse;
};

// TODO: See if data can be split up to take advantage of coalescing for a half-warp.
struct Contact_Surface
{
	// Contact point 0 is the contact point furthest in the 
	// counter clockwise direction for body 0.
	// Contact point 1 is the contact point furthest in the 
	// clockwise direction for body 0.

	uint bodies[2];
	Contact_Point_Position contact_point_positions[2];
	
	vec2 tangent;
	Contact_Point_Tangent contact_point_tangents[2];

	Contact_Point_Normal contact_point_normals[2];
};

layout(shared, binding = CONTACT_SURFACE_BINDING) restrict
buffer Contact_Surfaces
{
	Contact_Surface contact_surfaces[MAX_CONTACT_COUNT];
} contact_surfaces;

layout(shared, binding = CONTACT_COUNT_BINDING) uniform Contact_Count
{
	uint contact_count;
} contact_count;

layout(shared, binding = POSITION_BINDING) restrict readonly/*writeonly*/
buffer Positions
{
	ivec4 p[MAX_RIGID_BODY_COUNT];
} positions;

/*layout(shared, binding = VELOCITY_BINDING) restrict readonly
buffer Velocities
{
	ivec4 v[MAX_RIGID_BODY_COUNT];
} velocities;*/

layout(local_size_x = LOCAL_SIZE) in;
void main()
{
	if (gl_GlobalInvocationID.x >= contact_count.contact_count)
	{
		return;
	}

	uvec2 contact = contacts.contacts[gl_GlobalInvocationID.x];
	
	uvec4 triangles[2u] = uvec4[2u]
	(
		triangles.triangles[contact.x], 
		triangles.triangles[contact.y]
	);
	
	ivec4 body_positions[2u] = ivec4[2u]
	(
		/*positions_snapshot*/positions.p[triangles[0u].w], 
		/*positions_snapshot*/positions.p[triangles[1u].w]
	);

	float angle_0 = body_positions[0].z * RADIAN_INVERSE;
	float right_0_x = cos(angle_0);
	float right_0_y = sin(angle_0);
	mat2 local_to_offset_0 = mat2
	(
		right_0_x, right_0_y, 
		-right_0_y, right_0_x
	);

	float angle_1 = body_positions[1].z * RADIAN_INVERSE;
	float right_1_x = cos(angle_1);
	float right_1_y = sin(angle_1);
	mat2 local_to_offset_1 = mat2
	(
		right_1_x, right_1_y, 
		-right_1_y, right_1_x
	);

	vec2 body_0_to_1 = vec2(body_positions[1].xy - body_positions[0].xy);

	vec2 vertices[6u] = vec2[6u]
	(
		local_to_offset_0 * vertices.vertices[triangles[0u][0u]], 
		local_to_offset_0 * vertices.vertices[triangles[0u][1u]], 
		local_to_offset_0 * vertices.vertices[triangles[0u][2u]], 

		local_to_offset_1 * vertices.vertices[triangles[1u][0u]] + body_0_to_1, 
		local_to_offset_1 * vertices.vertices[triangles[1u][1u]] + body_0_to_1, 
		local_to_offset_1 * vertices.vertices[triangles[1u][2u]] + body_0_to_1
	);

	// TODO: Make sure that this fits in register memory
	vec2 normals[6u] = vec2[6u]
	(
		normalize(vec2(vertices[1u].y - vertices[0u].y, vertices[0u].x - vertices[1u].x)),
		normalize(vec2(vertices[2u].y - vertices[1u].y, vertices[1u].x - vertices[2u].x)), 
		normalize(vec2(vertices[0u].y - vertices[2u].y, vertices[2u].x - vertices[0u].x)), 
		
		normalize(vec2(vertices[4u].y - vertices[3u].y, vertices[3u].x - vertices[4u].x)), 
		normalize(vec2(vertices[5u].y - vertices[4u].y, vertices[4u].x - vertices[5u].x)), 
		normalize(vec2(vertices[3u].y - vertices[5u].y, vertices[5u].x - vertices[3u].x))
	);

	uint reference_edge = 0u;
	float min_penetration = dot(vertices[0u], normals[0u]) - min
	(
		min(dot(vertices[3u], normals[0u]), dot(vertices[4u], normals[0u])), 
		dot(vertices[5u], normals[0u])
	);

	float penetration = dot(vertices[1u], normals[1u]) - min
	(
		min(dot(vertices[3u], normals[1u]), dot(vertices[4u], normals[1u])), 
		dot(vertices[5u], normals[1u])
	);
	// TODO: See if it's faster to use boolean arithmetics instead of if statement
	if (penetration < min_penetration)
	{
		reference_edge = 1u;
		min_penetration = penetration;
	}

	penetration = dot(vertices[2u], normals[2u]) - min
	(
		min(dot(vertices[3u], normals[2u]), dot(vertices[4u], normals[2u])), 
		dot(vertices[5u], normals[2u])
	);
	// TODO: See if it's faster to use boolean arithmetics instead of if statement
	// Example: reference_edge = reference_edge + (penetration < min_penetration) & (2u - reference_edge)
	if (penetration < min_penetration)
	{
		reference_edge = 2u;
		min_penetration = penetration;
	}

	penetration = dot(vertices[3u], normals[3u]) - min
	(
		min(dot(vertices[0u], normals[3u]), dot(vertices[1u], normals[3u])), 
		dot(vertices[2u], normals[3u])
	);
	// TODO: See if it's faster to use boolean arithmetics instead of if statement
	if (penetration < min_penetration)
	{
		reference_edge = 3u;
		min_penetration = penetration;
	}

	penetration = dot(vertices[4u], normals[4u]) - min
	(
		min(dot(vertices[0u], normals[4u]), dot(vertices[1u], normals[4u])), 
		dot(vertices[2u], normals[4u])
	);
	// TODO: See if it's faster to use boolean arithmetics instead of if statement
	if (penetration < min_penetration)
	{
		reference_edge = 4u;
		min_penetration = penetration;
	}

	penetration = dot(vertices[5u], normals[5u]) - min
	(
		min(dot(vertices[0u], normals[5u]), dot(vertices[1u], normals[5u])), 
		dot(vertices[2u], normals[5u])
	);
	// TODO: See if it's faster to use boolean arithmetics instead of if statement
	if (penetration < min_penetration)
	{
		reference_edge = 5u;
		min_penetration = penetration;
	}

	// TODO: Maybe remove branching
	if (min_penetration < 0.0)
	{
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_tangents[0u].mass = 0.0;
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_tangents[0u].impulse = 0.0;
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_tangents[1u].mass = 0.0;
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_tangents[1u].impulse = 0.0;

		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[0u].mass = 0.0;
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[0u].impulse = 0.0;
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[1u].mass = 0.0;
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[1u].impulse = 0.0;
	}
	else
	{
		uint reference_body = reference_edge / 3u;
		
		uint incident_body_vertex_0 = (reference_body ^ 1u) * 3u;
		uint incident_body_vertex_1 = incident_body_vertex_0 + 1u;
		uint incident_body_vertex_2 = incident_body_vertex_0 + 2u;
		float projection_0 = dot(vertices[incident_body_vertex_0], normals[reference_edge]);
		float projection_1 = dot(vertices[incident_body_vertex_1], normals[reference_edge]);
		float projection_2 = dot(vertices[incident_body_vertex_2], normals[reference_edge]);
		// TODO: Remove branching
		uint local_primary_incident_vertex = 2u;
		if (projection_0 < projection_1 && projection_0 < projection_2)
		{
			local_primary_incident_vertex = 0u;
		}
		else if (projection_1 < projection_2)
		{
			local_primary_incident_vertex = 1u;
		}
		
		uint primary_incident_vertex = incident_body_vertex_0 + local_primary_incident_vertex;
		uint temp = local_primary_incident_vertex + 2u;
		uint left_secondary_incident_vertex = incident_body_vertex_0 + (temp % 3u);
		uint secondary_incident_vertex_side = uint
		(
			dot(normals[primary_incident_vertex], normals[reference_edge]) < 
			dot(normals[left_secondary_incident_vertex], normals[reference_edge])
		);
		
		vec2 primary_contact_point = vertices[primary_incident_vertex];
		uint secondary_incident_vertex = 
			incident_body_vertex_0 + (temp - secondary_incident_vertex_side) % 3u;
		vec2 secondary_contact_point = vertices[secondary_incident_vertex];
		vec2 secondary_to_primary = primary_contact_point - secondary_contact_point;
		vec2 tangent = vec2(normals[reference_edge].y, -normals[reference_edge].x);
		float secondary_to_primary_projection = dot(secondary_to_primary, tangent);
	
		uint reference_body_vertex_0 = reference_body * 3u;
		uint local_reference_edge = reference_edge - reference_body_vertex_0;

		uint primary_reference_vertex = reference_body_vertex_0 + (local_reference_edge + secondary_incident_vertex_side) % 3u;
		primary_contact_point += secondary_to_primary * min(0.0f, 
			dot(vertices[primary_reference_vertex] - vertices[primary_incident_vertex], tangent)
			/ secondary_to_primary_projection
		);

		uint secondary_reference_vertex = reference_body_vertex_0 + (local_reference_edge + (secondary_incident_vertex_side ^ 1u)) % 3u;
		secondary_contact_point += secondary_to_primary * max(0.0f, 
			dot(vertices[secondary_reference_vertex] - vertices[secondary_incident_vertex], tangent) 
			/ secondary_to_primary_projection
		);
		if (dot(secondary_contact_point - vertices[reference_edge], normals[reference_edge]) > 0.0)
		{
			secondary_contact_point = primary_contact_point;
		}

		secondary_incident_vertex_side ^= reference_body;
		uint primary_incident_vertex_side = secondary_incident_vertex_side ^ 1u;

		// TODO: Maybe store all vec2s in meters
		vec2 secondary_offset_0 = METER_INVERSE * vec2(-secondary_contact_point.y, secondary_contact_point.x);
		vec2 secondary_offset_1 = secondary_contact_point - body_0_to_1;
		secondary_offset_1 = METER_INVERSE * vec2(-secondary_offset_1.y, secondary_offset_1.x);
		
		vec2 primary_offset_0 = METER_INVERSE * vec2(-primary_contact_point.y, primary_contact_point.x);
		vec2 primary_offset_1 = primary_contact_point - body_0_to_1;
		primary_offset_1 = METER_INVERSE * vec2(-primary_offset_1.y, primary_offset_1.x);

		// TODO: See if it's faster to put all writes next to each other

		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_positions[secondary_incident_vertex_side].offsets[0] = secondary_offset_0;
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_positions[secondary_incident_vertex_side].offsets[1] = secondary_offset_1;
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_positions[primary_incident_vertex_side].offsets[0] = primary_offset_0;
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_positions[primary_incident_vertex_side].offsets[1] = primary_offset_1;

		float basis_sign = 1.0 - float(reference_body << 1u);
		tangent *= basis_sign;
		vec2 normal = normals[reference_edge] * basis_sign;
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].tangent = tangent;

		// TODO: Fetch masses from buffer
		float inverse_mass_0 = INVERSE_MASS;
		float inverse_inertia_0 = INVERSE_INERTIA;

		float inverse_mass_1 = INVERSE_MASS;
		float inverse_inertia_1 = INVERSE_INERTIA;

		// TODO: Handle infinite masses
		float temp_0 = dot(secondary_offset_0, tangent);
		float temp_1 = dot(secondary_offset_1, tangent);
		float secondary_tangent_mass = 1.0 / (
			inverse_mass_0 + inverse_inertia_0 * temp_0 * temp_0 + 
			inverse_mass_1 + inverse_inertia_1 * temp_1 * temp_1
		);

		temp_0 = dot(primary_offset_0, tangent);
		temp_1 = dot(primary_offset_1, tangent);
		float primary_tangent_mass = 1.0 / (
			inverse_mass_0 + inverse_inertia_0 * temp_0 * temp_0 + 
			inverse_mass_1 + inverse_inertia_1 * temp_1 * temp_1
		);

		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_tangents[secondary_incident_vertex_side].mass = secondary_tangent_mass;
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_tangents[primary_incident_vertex_side].mass = primary_tangent_mass;

		// TODO: Handle infinite masses

		float secondary_penetration = dot(vertices[reference_edge] - secondary_contact_point, normals[reference_edge]);
		float secondary_penetration_error = secondary_penetration - ALLOWED_PENETRATION;
		float secondary_target_normal_velocity = PENETRATION_VELOCITY_SCALE * max(0.0, secondary_penetration_error);
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[secondary_incident_vertex_side].target_velocity = secondary_target_normal_velocity;

		temp_0 = dot(secondary_offset_0, normal);
		temp_1 = dot(secondary_offset_1, normal);
		float secondary_normal_mass = 1.0 / (
			inverse_mass_0 + inverse_inertia_0 * temp_0 * temp_0 + 
			inverse_mass_1 + inverse_inertia_1 * temp_1 * temp_1
		);
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[secondary_incident_vertex_side].mass = secondary_normal_mass;

		float primary_penetration_error = min_penetration - ALLOWED_PENETRATION;
		float primary_target_normal_velocity = PENETRATION_VELOCITY_SCALE * max(0.0, primary_penetration_error);
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[primary_incident_vertex_side].target_velocity = primary_target_normal_velocity;

		temp_0 = dot(primary_offset_0, normal);
		temp_1 = dot(primary_offset_1, normal);
		float primary_normal_mass = 1.0 / (
			inverse_mass_0 + inverse_inertia_0 * temp_0 * temp_0 + 
			inverse_mass_1 + inverse_inertia_1 * temp_1 * temp_1
		);
		contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[primary_incident_vertex_side].mass = primary_normal_mass;
		/*
		vec2 secondary_impulse = 
		(
			contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_tangents[secondary_incident_vertex_side].impulse * tangent + 
			contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[secondary_incident_vertex_side].impulse * normal
		);
		vec2 primary_impulse = 
		(
			contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_tangents[primary_incident_vertex_side].impulse * tangent + 
			contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[primary_incident_vertex_side].impulse * normal
		);
		vec2 impulse_sum = secondary_impulse + primary_impulse;

		ivec3 delta_velocity_0 = ivec3
		(
			-METER * inverse_mass_0 * impulse_sum, 
			-RADIAN * inverse_inertia_0 * (dot(secondary_impulse, secondary_offset_0) + dot(primary_impulse, primary_offset_0))
		);

		ivec3 delta_velocity_1 = ivec3
		(
			METER * inverse_mass_1 * impulse_sum, 
			RADIAN * inverse_inertia_1 * (dot(secondary_impulse, secondary_offset_1) + dot(primary_impulse, primary_offset_1))
		);

		atomicAdd(velocities.v[triangles[0u].w].x, delta_velocity_0.x);
		atomicAdd(velocities.v[triangles[0u].w].y, delta_velocity_0.y);
		atomicAdd(velocities.v[triangles[0u].w].z, delta_velocity_0.z);

		atomicAdd(velocities.v[triangles[1u].w].x, delta_velocity_1.x);
		atomicAdd(velocities.v[triangles[1u].w].y, delta_velocity_1.y);
		atomicAdd(velocities.v[triangles[1u].w].z, delta_velocity_1.z);*/
/*
#if DIRECT_POSITION_CORRECTION == 1
		if (secondary_penetration_error > 0.0 || primary_penetration_error > 0.0)
		{
			vec2 secondary_position_impulse = 
			(
				POSITION_IMPULSE_SCALE * secondary_normal_mass * secondary_penetration_error
			) * normal;
			vec2 primary_position_impulse = (
				POSITION_IMPULSE_SCALE * primary_normal_mass * primary_penetration_error
			) * normal;
			vec2 position_impulse_sum = secondary_position_impulse + primary_position_impulse;

			// TODO: Store METER * inverse_mass_0 in temporary, same for RADIAN * inverse_inertia_0, etc.
			ivec3 delta_position_0 = ivec3
			(
				-METER * inverse_mass_0 * position_impulse_sum, 
				-RADIAN * inverse_inertia_0 * (dot(secondary_position_impulse, secondary_offset_0) + dot(primary_position_impulse, primary_offset_0))
			);

			ivec3 delta_position_1 = ivec3
			(
				METER * inverse_mass_1 * position_impulse_sum, 
				RADIAN * inverse_inertia_1 * (dot(secondary_position_impulse, secondary_offset_1) + dot(primary_position_impulse, primary_offset_1))
			);

			atomicAdd(positions.p[triangles[0u].w].x, delta_position_0.x);
			atomicAdd(positions.p[triangles[0u].w].y, delta_position_0.y);
			atomicAdd(positions.p[triangles[0u].w].z, delta_position_0.z);

			atomicAdd(positions.p[triangles[1u].w].x, delta_position_1.x);
			atomicAdd(positions.p[triangles[1u].w].y, delta_position_1.y);
			atomicAdd(positions.p[triangles[1u].w].z, delta_position_1.z);
		}
#endif
*/
	}
}
