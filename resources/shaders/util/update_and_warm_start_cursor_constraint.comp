layout(shared, binding = CURSOR_CONSTRAINED_POINT_BINDING) uniform Cursor_Constrained_Point
{
	uint body;
	vec2 local_point;
} cursor_constrained_point;

layout(shared, binding = CURSOR_POSITION_BINDING) uniform Cursor_Position
{
	ivec2 position;
} cursor_position;

layout(shared, binding = CURSOR_CONSTRAINT_BINDING) restrict 
buffer Cursor_Constraint
{
	vec2 offset;
	vec2 target_velocity;
	mat2 mass;
	vec2 impulse;	// TODO: CLEAR THE IMPULSE WHEN NEW CONSTRAINT IS CREATED
} cursor_constraint;

layout(shared, binding = POSITION_BINDING) restrict readonly
buffer Positions
{
	ivec4 p[MAX_RIGID_BODY_COUNT];
} positions;

layout(shared, binding = VELOCITY_BINDING) restrict writeonly
buffer Velocities
{
	ivec4 v[MAX_RIGID_BODY_COUNT];
} velocities;

layout(local_size_x = 1u) in;
void main()
{
	uint body = cursor_constrained_point.body;
	vec2 local_point = cursor_constrained_point.local_point;

	ivec4 body_position = positions.p[body];

	float angle = body_position.z * RADIAN_INVERSE;
	float right_x = cos(angle);
	float right_y = sin(angle);
	
	// TODO: Fetch masses from buffer
	float inverse_mass = INVERSE_MASS;
	float inverse_inertia = INVERSE_INERTIA;

	// TODO: See if it's faster to construct and multiply with a matrix
	vec2 offset = local_point.x * vec2(right_x, right_y) + local_point.y * vec2(-right_y, right_x);
	vec2 target_velocity = VELOCITY_SCALE * (vec2(cursor_position.position - body_position.xy) - offset);
	offset = vec2(-offset.y, offset.x);
	float secondary_diagonal = inverse_inertia * offset.x * offset.y;
	mat2 mass = inverse(mat2
	(
		inverse_mass + inverse_inertia * offset.x * offset.x, secondary_diagonal, 
		secondary_diagonal, inverse_mass + inverse_inertia * offset.y * offset.y
	));
	cursor_constraint.offset = offset;
	cursor_constraint.target_velocity = target_velocity;
	cursor_constraint.mass = mass;
	
	vec2 impulse = cursor_constraint.impulse;

	ivec3 delta_velocity = ivec3
	(
		METER * inverse_mass * impulse, 
		RADIAN * inverse_inertia * dot(impulse, offset)
	);

	atomicAdd(velocities.v[body].x, delta_velocity.x);
	atomicAdd(velocities.v[body].y, delta_velocity.y);
	atomicAdd(velocities.v[body].z, delta_velocity.z);
}
