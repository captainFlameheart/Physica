struct Distance_Constraint
{
	uvec2 bodies;
	vec2 local_points[2u];
	vec2 offsets[2u];
	vec2 direction;
	float max_distance;
	float target_velocity;
	float mass;
	float impulse;
};

layout(shared, binding = DISTANCE_CONSTRAINT_BINDING) restrict
buffer Distance_Constraints
{
	readonly uint count;
	Distance_Constraint distance_constraints[MAX_DISTANCE_CONSTRAINT_COUNT];
} distance_constraints;

layout(shared, binding = VELOCITY_BINDING) restrict
buffer Velocities
{
	ivec4 v[MAX_RIGID_BODY_COUNT];
} velocities;

layout(local_size_x = LOCAL_SIZE) in;
void main()
{
	if (gl_GlobalInvocationID.x >= distance_constraints.count)
	{
		return;
	}

	uvec2 bodies = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].bodies;
	vec2 offset_0 = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].offsets[0u];
	vec2 offset_1 = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].offsets[1u];
	vec2 direction = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].direction;
	float impulse = distance_constraints.distance_constraints[gl_GlobalInvocationID.x].impulse;
	
	// TODO: Fetch masses from buffer
	float inverse_mass_0 = INVERSE_MASS;
	float inverse_inertia_0 = INVERSE_INERTIA;

	float inverse_mass_1 = INVERSE_MASS;
	float inverse_inertia_1 = INVERSE_INERTIA;

	vec2 impulse_vector = impulse * direction;

	ivec3 delta_velocity_0 = ivec3
	(
		-METER * inverse_mass_0 * impulse_vector, 
		-RADIAN * inverse_inertia_0 * dot(impulse_vector, offset_0)
	);

	ivec3 delta_velocity_1 = ivec3
	(
		METER * inverse_mass_1 * impulse_vector, 
		RADIAN * inverse_inertia_1 * dot(impulse_vector, offset_1)
	);

	atomicAdd(velocities.v[bodies.x].x, delta_velocity_0.x);
	atomicAdd(velocities.v[bodies.x].y, delta_velocity_0.y);
	atomicAdd(velocities.v[bodies.x].z, delta_velocity_0.z);

	atomicAdd(velocities.v[bodies.y].x, delta_velocity_1.x);
	atomicAdd(velocities.v[bodies.y].y, delta_velocity_1.y);
	atomicAdd(velocities.v[bodies.y].z, delta_velocity_1.z);
}
