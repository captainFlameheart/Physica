struct Contact_Point_Position
{
	vec2 offsets[2];
};

struct Contact_Point_Tangent
{
	float mass;
	float impulse;
};

struct Contact_Point_Normal
{
	float target_velocity;
	float mass;
	float impulse;
};

// TODO: See if data can be split up to take advantage of coalescing for a half-warp.
struct Contact_Surface
{
	// Contact point 0 is the contact point furthest in the 
	// counter clockwise direction for body 0.
	// Contact point 1 is the contact point furthest in the 
	// clockwise direction for body 0.

	uint bodies[2];
	Contact_Point_Position contact_point_positions[2];
	
	vec2 tangent;
	Contact_Point_Tangent contact_point_tangents[2];

	Contact_Point_Normal contact_point_normals[2];
};

layout(shared, binding = CONTACT_SURFACE_BINDING) restrict
buffer Contact_Surfaces
{
	Contact_Surface contact_surfaces[MAX_CONTACT_COUNT];
} contact_surfaces;

layout(shared, binding = PERSISTENT_CONTACT_COUNT_BINDING) uniform Persistent_Contact_Count
{
	uint persistent_contact_count;
} persistent_contact_count;

layout(shared, binding = BODY_MASSES_BINDING) restrict readonly
buffer Body_Masses
{
	vec2 masses[MAX_RIGID_BODY_COUNT];	// mass: (inverse_mass, inverse_inertia)
} body_masses;

layout(shared, binding = VELOCITY_BINDING) restrict writeonly
buffer Velocities
{
	ivec4 v[MAX_RIGID_BODY_COUNT];
} velocities;

layout(local_size_x = LOCAL_SIZE) in;
void main()
{
	if (gl_GlobalInvocationID.x >= persistent_contact_count.persistent_contact_count)
	{
		return;
	}

	uint body_0 = contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].bodies[0u];
	uint body_1 = contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].bodies[1u];

	vec2 offset_0_0 = contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_positions[0u].offsets[0u];
	vec2 offset_0_1 = contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_positions[0u].offsets[1u];

	vec2 offset_1_0 = contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_positions[1u].offsets[0u];
	vec2 offset_1_1 = contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_positions[1u].offsets[1u];

	vec2 tangent = contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].tangent;
	
	float tangent_impulse_0 = contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_tangents[0u].impulse;
	float tangent_impulse_1 = contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_tangents[1u].impulse;
	
	vec2 normal = vec2(-tangent.y, tangent.x);

	float normal_impulse_0 = contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[0u].impulse;
	float normal_impulse_1 = contact_surfaces.contact_surfaces[gl_GlobalInvocationID.x].contact_point_normals[1u].impulse;

	vec2 impulse_0 = tangent_impulse_0 * tangent + normal_impulse_0 * normal;
	vec2 impulse_1 = tangent_impulse_1 * tangent + normal_impulse_1 * normal;
	vec2 impulse_sum = impulse_0 + impulse_1;

	// TODO: Fetch masses from buffer
	vec2 mass_0 = body_masses.masses[body_0];
	float inverse_mass_0 = mass_0.x;//INVERSE_MASS;
	float inverse_inertia_0 = mass_0.y;//INVERSE_INERTIA;

	vec2 mass_1 = body_masses.masses[body_1];
	float inverse_mass_1 = mass_1.x;//INVERSE_MASS;
	float inverse_inertia_1 = mass_1.y;//INVERSE_INERTIA;

	ivec3 delta_velocity_0 = ivec3
	(
		-METER * inverse_mass_0 * impulse_sum, 
		-RADIAN * inverse_inertia_0 * (dot(impulse_0, offset_0_0) + dot(impulse_1, offset_1_0))
	);

	ivec3 delta_velocity_1 = ivec3
	(
		METER * inverse_mass_1 * impulse_sum, 
		RADIAN * inverse_inertia_1 * (dot(impulse_0, offset_0_1) + dot(impulse_1, offset_1_1))
	);

	atomicAdd(velocities.v[body_0].x, delta_velocity_0.x);
	atomicAdd(velocities.v[body_0].y, delta_velocity_0.y);
	atomicAdd(velocities.v[body_0].z, delta_velocity_0.z);

	atomicAdd(velocities.v[body_1].x, delta_velocity_1.x);
	atomicAdd(velocities.v[body_1].y, delta_velocity_1.y);
	atomicAdd(velocities.v[body_1].z, delta_velocity_1.z);
}
