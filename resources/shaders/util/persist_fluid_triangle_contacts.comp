const float positive_infinity = uintBitsToFloat(0x7F800000);
const float negative_infinity = uintBitsToFloat(0xFF800000);

layout(shared, binding = FLUID_TRIANGLE_CONTACT_COUNT_BINDING) uniform Fluid_Triangle_Contact_Count
{
	uint count;
} fluid_triangle_contact_count;

// TODO: Add friction data?
struct Fluid_Triangle_Contact
{
	uint triangle;
	float mass;
	float impulse;
	uint particle;
	uint body;
	float target_velocity;
	vec2 offset;
	vec2 direction;
	vec2 impulse_range;
};

layout(shared, binding = FLUID_TRIANGLE_CONTACT_BINDING) restrict
buffer Fluid_Triangle_Contacts
{
	Fluid_Triangle_Contact contacts[MAX_FLUID_TRIANGLE_CONTACT_COUNT];
} fluid_triangle_contacts;

layout(shared, binding = POSITION_BINDING) restrict readonly
buffer Positions
{
	ivec4 p[MAX_RIGID_BODY_COUNT];
} positions;

layout(shared, binding = TRIANGLE_BINDING) restrict readonly
buffer Triangles
{
	uvec4 triangles[MAX_TRIANGLE_COUNT];	// Triangle: (vertex_0, vertex_1, vertex_2, body)
} triangles;

layout(shared, binding = VERTEX_BINDING) restrict readonly
buffer Vertices
{
	vec2 vertices[MAX_VERTEX_COUNT];
} vertices;

layout(shared, binding = FLUID_POSITION_BINDING) restrict readonly
buffer Fluid_Position
{
	ivec2 p[MAX_FLUID_PARTICLE_COUNT];
} fluid_position;

layout(shared, binding = FLUID_VELOCITY_BINDING) restrict readonly
buffer Fluid_Velocity
{
	ivec2 v[MAX_FLUID_PARTICLE_COUNT];
} fluid_velocity;

layout(local_size_x = LOCAL_SIZE) in;
void main()
{
	if (gl_GlobalInvocationID.x >= fluid_triangle_contact_count.count)
	{
		return;
	}

	uint triangle_index = fluid_triangle_contacts.contacts[gl_GlobalInvocationID.x].triangle;
	uint particle_index = fluid_triangle_contacts.contacts[gl_GlobalInvocationID.x].particle;
	uint body_index = fluid_triangle_contacts.contacts[gl_GlobalInvocationID.x].body;	

	uvec4 triangle = triangles.triangles[triangle_index];
	vec2 local_vertices[3u] = vec2[3u]
	(
		vertices.vertices[triangle.x], 
		vertices.vertices[triangle.y], 
		vertices.vertices[triangle.z]
	);

	ivec4 body_position = positions.p[body_index];

	ivec2 particle_position = fluid_position.p[particle_index];

	vec2 particle_offset = vec2(particle_position - body_position.xy);
	float angle = body_position.z * RADIAN_INVERSE;
	vec2 right = vec2(cos(angle), sin(angle));
	vec2 up = vec2(-right.y, right.x);
	vec2 local_particle_position = vec2(dot(particle_offset, right), dot(particle_offset, up));

	vec2 normals[3u] = vec2[3u]
	(
		local_vertices[0u] - local_vertices[1u], 
		local_vertices[1u] - local_vertices[2u], 
		local_vertices[2u] - local_vertices[0u]
	);
	normals[0u] = normalize(vec2(normals[0u].y, -normals[0u].x));
	normals[1u] = normalize(vec2(normals[1u].y, -normals[1u].x));
	normals[2u] = normalize(vec2(normals[2u].y, -normals[2u].x));

	// TODO: Remove branching

	uint reference_edge = 0u;
	vec2 vertex_0_to_particle = local_particle_position - local_vertices[0u];
	float min_penetration = dot(normals[0u], vertex_0_to_particle);

	vec2 vertex_1_to_particle = local_particle_position - local_vertices[1u];
	float penetration = dot(normals[1u], vertex_1_to_particle);
	if (penetration < min_penetration)
	{
		reference_edge = 1u;
		min_penetration = penetration;
	}

	vec2 vertex_2_to_particle = local_particle_position - local_vertices[2u];
	penetration = dot(normals[2u], vertex_2_to_particle);
	if (penetration < min_penetration)
	{
		reference_edge = 2u;
		min_penetration = penetration;
	}

	if (min_penetration < 0.0)
	{
		fluid_triangle_contacts.contacts[gl_GlobalInvocationID.x].mass = 0.0;
		return;
	}

	vec2 offset = vec2(-particle_offset.y, particle_offset.x);
	vec2 direction = normals[reference_edge];

	// TODO: Fetch from buffer
	float particle_inverse_mass = PARTICLE_INVERSE_MASS;
	float body_inverse_mass = BODY_INVERSE_MASS;
	float body_inverse_inertia = BODY_INVERSE_INERTIA;

	float old_mass = fluid_triangle_contacts.contacts[gl_GlobalInvocationID.x].mass;

	float temp = dot(offset, direction);
	float mass = 1.0 / (
		particle_inverse_mass + 
		body_inverse_mass + body_inverse_inertia * temp * temp
	);
	fluid_triangle_contacts.contacts[gl_GlobalInvocationID.x].mass = mass;

	float target_velocity = 0.002 * (min_penetration - (0.05 * (METER)));
	if (old_mass == 0.0)
	{
		// TODO: Bounce
		// IMPORTANT TODO: COMPUTE (SCALED) INITIAL IMPULSE BASED ON VELOCITY FOR FASTER CONVERGENCE
		fluid_triangle_contacts.contacts[gl_GlobalInvocationID.x].impulse = 0.0;
	}
	// IMPORTANT TODO: Always change impulse slightly based on velocities for faster convergence
	fluid_triangle_contacts.contacts[gl_GlobalInvocationID.x].target_velocity = target_velocity;
	fluid_triangle_contacts.contacts[gl_GlobalInvocationID.x].offset = offset;
	fluid_triangle_contacts.contacts[gl_GlobalInvocationID.x].direction = direction;
	fluid_triangle_contacts.contacts[gl_GlobalInvocationID.x].impulse_range = vec2(0.0, positive_infinity);
}
