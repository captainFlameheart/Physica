layout(shared, binding = TRIANGLE_BINDING) restrict readonly
buffer Triangles
{
	uvec4 triangles[MAX_TRIANGLE_COUNT];	// Triangle: (vertex_0, vertex_1, vertex_2, body)
} triangles;

layout(shared, binding = POSITION_BINDING) restrict readonly
buffer Positions
{
	ivec4 p[MAX_RIGID_BODY_COUNT];
} positions;

layout(shared, binding = VERTEX_BINDING) restrict readonly
buffer Vertices
{
	vec2 vertices[MAX_VERTEX_COUNT];
} vertices;

layout(shared, binding = BOUNDING_BOX_BINDING) restrict
buffer Bounding_Boxes
{
	ivec4 boxes[MAX_TRIANGLE_COUNT];	// Bounding box: (min_x, min_y, max_x, max_z)
} bounding_boxes;

/* TODO: Use velocities for computing better fat aabb
IMPROVEMENT: DO NOT READ FROM VELOCITY BUFFER. Instead use 
the displacement from the old AABB to the new AABB as an indication 
of the trajectory.

layout(shared, binding = VELOCITY_BINDING) restrict readonly 
buffer Velocities
{
	ivec4 v[MAX_RIGID_BODY_COUNT];
} velocities;*/

struct Changed_Bounding_Box
{
	uint index;
	int min_x;
	int min_y;
	int max_x;
	int max_y;
};

layout(shared, binding = CHANGED_BOUNDING_BOX_BINDING)
buffer Changed_Bounding_Boxes
{
	restrict uint size; // TODO: coherent MIGHT be necessary (conflicting reports)
	restrict writeonly Changed_Bounding_Box boxes[MAX_TRIANGLE_COUNT];
} changed_bounding_boxes;

layout(local_size_x = LOCAL_SIZE) in;
void main()
{
	// TODO: Think about how to handle x, y going out of bounds

	uvec4 triangle = triangles.triangles[gl_GlobalInvocationID.x];
	ivec4 body_position = positions.p[triangle.w];
	float angle = body_position.z * RADIAN_INVERSE;
	float right_x = cos(angle);
	float right_y = sin(angle);
	mat2 local_to_offset = mat2
	(
		right_x, right_y, 
		-right_y, right_x
	);
	vec2 offset_0 = local_to_offset * vertices.vertices[triangle[0]];
	vec2 offset_1 = local_to_offset * vertices.vertices[triangle[1]];
	vec2 offset_2 = local_to_offset * vertices.vertices[triangle[2]];
	ivec2 min = body_position.xy + ivec2(min(min(offset_0, offset_1), offset_2));
	ivec2 max = body_position.xy + ivec2(max(max(offset_0, offset_1), offset_2));
	ivec4 bounding_box = bounding_boxes.boxes[gl_GlobalInvocationID.x];
		
	if (any(lessThan(min, bounding_box.xy)) || any(greaterThan(max, bounding_box.zw)))
	{
		bounding_box = ivec4(min - PADDING, max + PADDING);
		bounding_boxes.boxes[gl_GlobalInvocationID.x] = bounding_box;
		uint push_index = atomicAdd(changed_bounding_boxes.size, 1u);
		changed_bounding_boxes.boxes[push_index] = Changed_Bounding_Box
		(
			gl_GlobalInvocationID.x, 
			bounding_box.x, bounding_box.y, bounding_box.z, bounding_box.w
		);
	}
}
