layout(local_size_x = process_point_masses_local_size) in;
void main()
{
	uint index = gl_GlobalInvocationID.x;
	uint count = fixed_data.read_counts[point_mass_count_index];
	if (index >= count)
	{
		return;
	}

	uint position_velocity_base = fixed_data.point_mass_position_velocity_base;
	// uint inverse_mass_base = fixed_data.point_mass_inverse_mass_base;
	uint read_force_turn_flags_base = fixed_data.point_mass_read_force_turn_flags_base;
	uint read_impulses_base = fixed_data.point_mass_read_impulses_base;
	uint write_force_turn_flags_base = fixed_data.point_mass_write_force_turn_flags_base;
	uint write_impulses_base = fixed_data.point_mass_write_impulses_base;

	uint position_velocity_index = position_velocity_base + index;
	// uint inverse_mass_index = inverse_mass_base + index;
	uint read_force_turn_flags_index = read_force_turn_flags_base + index;
	uint read_impulses_index = read_impulses_base + index;
	uint write_force_turn_flags_index = write_force_turn_flags_base + index;
	uint write_impulses_index = write_impulses_base + index;

	uvec4 position_velocity = uvec4_data.data[position_velocity_index];
	// float inverse_mass = float_data.data[inverse_mass_index];
	uvec4 force_turn_flags = uvec4_data.data[read_force_turn_flags_index];
	uvec4 impulses = uvec4_data.data[read_impulses_index];

	// TODO: Update position based on position impulse
	position_velocity.zw += force_turn_flags.xy + impulses.xy;
	position_velocity.xy += position_velocity.zw;

	uvec4_data.data[position_velocity_index] = position_velocity;

	force_turn_flags.z += 1;

	uvec4_data.data[read_force_turn_flags_index] = force_turn_flags;

	uvec4 previous_force_turn_flags = uvec4_data.data[write_force_turn_flags_index];
	impulses.xy += force_turn_flags.xy - previous_force_turn_flags.xy;

	// TODO: Update position impulse

	uvec4_data.data[read_impulses_index] = impulses;

	uvec4_data.data[write_force_turn_flags_index] = force_turn_flags;
	uvec4_data.data[write_impulses_index] = uvec4(0u);
}
