TODO: Investigate and implement correct handling of OpenGL data types and C++ data types 
(e.g. GLfloat vs float, endianness, etc.)

TODO: Implement a way to convert a fixed-point angle in the range [-M, M[ to a floating-point angle 
in the range [-PI, PI[ so that we can get cos and sin values with equal precision regardless of 
angle scale.

Part of the model: When a fixed-point value (such as x-coordinate or angle) goes out of bounds 
it will wrap around. We embrace this as a FEATURE, NOT a BUG, since its a feature of ints. 
Late game players that know of this can use this to their advantage to teleport themselves/other 
objects from one side of the map to the opposite side of the map.

TODO: Enforce static constant compiler evaluations.

TODO: Make sure to use the "restrict" memory qualifier for shader storage 
blocks.

TODO: Check if "Draw*Indirect commands" can be used to reduce transactions between CPU and GPU. 
Also check out GL_DISPATCH_INDIRECT_BUFFER.

TODO: Add logic so that the current number of rigid bodies does not exceed the maximum allowed number 
of rigid bodies. Do this for other object buffers as well.

TODO: Test to see if duplicating data in order to perform hardware fetching of 
vertex/triangle attributes from a VAO with DrawArrays or DrawElements is better 
than performing a random access in shader.

TODO: Utilize the 4th available rigid body position/velocity component for incrementing time so 
that we know how long a certain rigid body has been alive. This could be used for time-dependent 
effects such as light pulses/flickers -> creates atmoshpere for free! It could also be used to 
keep track of when a bomb is to explode, or to fade out a particle (with rotation, such as a snow flake)
and then remove it once its gone. Thus, the rigid body integration becomes more general than 
just for rigid bodies that contain triangles (A SNOWFLAKE IS ALSO A RIGID BODY!).
